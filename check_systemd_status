#!/usr/bin/env python3

# Nagios/Icinga plugin for checking systemd services status.
#
# Copyright (C) 2017 Felix Geyer <debfx@fobos.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 or (at your option)
# version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import subprocess
import sys

RESULT_OK = 0
RESULT_WARNING = 1
RESULT_CRITICAL = 2
RESULT_UNKNOWN = 3

RESULT_STRING = {
    RESULT_OK: "OK",
    RESULT_WARNING: "WARNING",
    RESULT_CRITICAL: "CRITICAL",
    RESULT_UNKNOWN: "UNKNOWN",
}


def run_process(cmd):
    try:
        output = subprocess.check_output(cmd, universal_newlines=True)
        return (0, output.strip())
    except subprocess.CalledProcessError as e:
        return (e.returncode, e.output.strip())


def check_systemd_status():
    status_result = run_process(["systemctl", "is-system-running"])

    check_result = [RESULT_UNKNOWN, status_result[1]]

    if status_result[0] != 0:
        check_result[0] = RESULT_WARNING

        if status_result[1] == "degraded":
            failed_output = run_process(["systemctl", "list-units", "--state=failed"])
            if failed_output[1]:
                check_result[1] += "\n\n" + failed_output[1]
    else:
        check_result[0] = RESULT_OK

    return check_result


def parse_properties(lines):
    properties = {}

    for line in lines:
        pos = line.find("=")
        if pos > 0:
            properties[line[:pos]] = line[pos + 1 :]

    return properties


def check_service_status(unit, check_running):
    active_result = run_process(["systemctl", "show", "-p", "ActiveState,SubState", unit])
    properties = parse_properties(active_result[1].splitlines())

    if active_result[0] == 0 and "ActiveState" in properties and "SubState" in properties:
        check_result = [
            RESULT_UNKNOWN,
            f"{unit} {properties['ActiveState']} ({properties['SubState']})",
        ]

        if properties["ActiveState"] == "active" and (not check_running or properties["SubState"] == "running"):
            check_result[0] = RESULT_OK
        else:
            check_result[0] = RESULT_CRITICAL
            status_result = run_process(["systemctl", "status", unit])
            if status_result[1]:
                check_result[1] += "\n\n" + status_result[1]
    else:
        check_result = [
            RESULT_UNKNOWN,
            f"{unit} unknown\n\n{active_result[1]}",
        ]

    return check_result


def main():
    os.environ["LC_ALL"] = "C"

    parser = argparse.ArgumentParser(description="Icinga plugin for checking systemd status.")
    parser.add_argument(
        "--system",
        action="store_true",
        help="Check the system status. Mutually exclusive with --unit.",
    )
    parser.add_argument(
        "--unit",
        help="Check the specific systemd unit. Mutually exclusive with --system.",
    )
    parser.add_argument(
        "--unit-running",
        action="store_true",
        help="Check that the unit is running on top of being active.",
    )
    args = parser.parse_args()

    if not args.system and not args.unit:
        result = (RESULT_UNKNOWN, "One of --system and --unit is required")
    elif args.system and args.unit:
        result = (RESULT_UNKNOWN, "--system and --unit are mutually exclusive")
    else:
        try:
            if args.system:
                result = check_systemd_status()
            else:
                result = check_service_status(args.unit, args.unit_running)
        except Exception as e:
            result = (
                RESULT_UNKNOWN,
                f"Exception {e.__class__.__name__}\n\n{e}",
            )

    print(f"SYSTEMD {RESULT_STRING.get(result[0], RESULT_STRING[RESULT_UNKNOWN])}: {result[1]}")
    sys.exit(result[0])


if __name__ == "__main__":
    main()
